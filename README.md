---
layout: post
title: A Project in Modern C++
tags: cpp coding project
categories: demo
---

## Introduction
The Matrix digital rain is an effect of glowing green characters streaming down a black screen and is one of cinema’s most iconic visuals. This project set out to recreate that effect in C++ as a way to exercise modern C++ features and good design practices. The result is a console-based digital rain simulation that mimics the classic code rain from The Matrix. 

In building this, I used modern c++ features such as multi-threading, and RAII-based resource management. In this blog , I will walk through the project’s development, beginning with the overall design and testing approach, then go into the core algorithm that generates the effect. Next, I'll discuss challenges encountered (such as flicker and concurrency issues) and how I solved them. Finally, I’ll reflect on the experience and highlight insights about modern C++ techniques (like object-oriented design, and RAII) that were applied. 

## Design and Testing
From the start, I adopted an object-oriented design for the sake of clarity and maintainability. The project’s architecture centers around a DigitalRain class (and a few helper structures) that contain all the functionality of the rain effect. Key design goals were encapsulation, separation of concerns, and adherence to C++ best practices. To meet these goals, internal data structures are kept private and manipulated only through member functions. For example, the console’s grid of characters is a private member of DigitalRain, and methods are used to update it rather than exposing the raw data. This ensures that the rest of the program can't inadvertently corrupt the state of the rain simulation, following a core idea of encapsulation which is to only allow access to data through well-defined interfaces. To manage the streaming code columns, the design uses classes and structures that model a rain column. Each column can be thought of as an object with properties like its current position, speed, and characters. I chose to store collections of these in standard containers like std::vector, taking advantage of the C++ Standard Library. 
For instance, a std::vector<char> might hold the characters in a column, and a std::vector<Column> might hold all column objects. Using vectors automatically handles memory allocation and deallocation (thanks to RAII), so I don’t have to manually manage dynamic arrays, reducing the chance of memory leaks or pointer bugs. Construction and destruction of objects are carefully handled. The DigitalRain class constructor sets up the initial state: it allocates the screen buffer (initialisea a 2D vector for the screen of width W and height H), spawns threads for animation. The destructor is equally important: it stops the threads and releases resources. In my implementation, when a DigitalRain object goes out of scope, it signals all worker threads to stop and then joins them (using a shared flag). This ensures a clean shutdown with no stray threads. This pattern is a demonstration of RAII (Resource Acquisition Is Initialization) acquiring resources (memory, threads, etc.) in the constructor and releasing them in the destructor​.

RAII simplifies resource management and prevents leaks by tying resources to object lifetimes. C++ Core Guidelines advise using RAII to prevent leaks as a fundamental best practice​. I also gave thought to the Rule of Five in my class design. If a class manages resources, C++ programmers must consider copy and move semantics. In my case, copying a DigitalRain object doesn’t make much sense since I wouldn’t want two active simulations sharing the same threads, so I deleted the copy constructor and copy assignment operator. However, I still explicitly defined a destructor (to join threads) and a move constructor/assignment if to transfer ownership of the simulation. The Rule of Five states that if a class needs a user-defined destructor, copy, or move operation, it likely needs all of them​. By following this rule, we ensured that our class’s behavior is well-defined under all circumstances. For example, we declared the copy constructor and assignment as deleted to avoid accidental copying, and (if we allowed moves) we’d define those to safely transfer the internal state (though in this project, move semantics were not heavily utilized). During development, we followed an iterative testing approach. We started by testing the logic in a single-threaded context (e.g., updating one column in a loop) to ensure the basic algorithm worked. Then, we introduced multiple columns and threads, gradually increasing complexity. At each step, the program was run in a console to visually confirm that the rain effect looked correct (columns falling at random speeds, characters changing, etc.). We also used assertions and sanity checks in the code during debugging – for instance, asserting that array indices were within bounds or that the number of threads spawned matched the number of columns. These tests were crucial in catching off-by-one errors and ensuring stable performance before moving on. By the end, we had a stable design where each component (random generation, threading, rendering) had been individually verified. The modular OOP design made it easier to isolate and fix issues; for example, the column update logic could be tested independently of the rendering to the screen. In summary, the design emphasizes clean separation (using classes/objects), resource safety (RAII and proper constructors/destructors), and the use of modern C++ library facilities. Testing early and often, in small increments, helped validate the design. This careful planning upfront laid a strong foundation for implementing the rain effect algorithm and tackling the challenges of multi-threaded animation.

## Algorithm
With the design in place, the core algorithm brings the digital rain to life. The program essentially maintains a matrix of characters representing the console screen. Let’s call the dimensions width (number of columns of text) and height (number of rows). At any given time, each position in this matrix holds either a green “code” character or a blank space. The simulation updates this matrix continuously to create the illusion of rain:
Initialize the screen buffer: We start with an empty screen (all spaces). We can represent the screen as a std::vector<std::string> or similar (a vector of strings, each string being one row of the console). Another approach is a 2D vector std::vector<std::vector<char>>. Either way, it’s a grid that we will update repeatedly.
Spawn rain columns: Each column of the rain can be updated independently. We use std::thread to create a worker thread for each column (or for a group of columns) to update that column’s characters over time. C++11’s <thread> library allows us to run functions concurrently – “Threads enable programs to execute across several processor cores.”​

 In our case, each thread runs a loop that updates one column of the screen buffer continuously.
Random character generation: To fill the rain with seemingly random symbols, we use the <random> library. Specifically, we use std::mt19937, which is a Mersenne Twister pseudorandom number generator. The Mersenne Twister is known for producing high-quality random numbers and is the recommended modern alternative to the old C rand() function​. In fact, std::mt19937 (from <random>) generates 32-bit unsigned integers in a deterministic but statistically uniform sequence​. We pair this with a distribution, for example std::uniform_int_distribution<int> to pick a random character code within a range (such as ASCII codes for ‘0’-‘9’ or ‘A’-‘Z’, or a custom set of Matrix glyphs). Each time a new character needs to appear at the top of a column, we sample from this random generator. This produces the chaotic, ever-changing code rain look.
Now, how does the update loop work for each column? Essentially, each thread executes something like this (simplified):

while (simulationRunning) {
    // Choose a new random character for the top of this column
    char newChar = randomCharGenerator();
    // Lock the buffer while updating to avoid conflicts
    {
        std::lock_guard<std::mutex> lock(bufferMutex);
        // Drop the column: move each character down one row
        for (int row = height - 1; row > 0; --row) {
            screenBuffer[row][colIndex] = screenBuffer[row-1][colIndex];
        }
        screenBuffer[0][colIndex] = newChar; // put new char at top
    }
    // Sleep for a bit to control the speed of this column
    std::this_thread::sleep_for(std::chrono::milliseconds(columnSpeed));
}

In this pseudo-code, colIndex is the index of the column this thread is handling, screenBuffer is our shared 2D array of characters, and bufferMutex is a std::mutex protecting the buffer. We use a std::lock_guard<std::mutex> to automatically lock the mutex at the start of the block and unlock it at the end (RAII for locks). This ensures that while a column is updating the shared buffer, no other column/thread interferes in a way that corrupts data. Each column shifts all characters one step down (overwriting the last row, which falls off the screen), and inserts a new random character at the top. Then the thread sleeps for some milliseconds – possibly each column has a slightly different random speed to make the rain less uniform. One important technique used here is double buffering for rendering output. Without double buffering, if we directly print updates to the console as they happen, the user might see tearing or flickering (partial updates of the screen). Double buffering means we maintain two versions of the screen: one that is currently displayed, and one that is being drawn to in the background. In practice, our screenBuffer can act as the back buffer that threads write into. Meanwhile, the main thread can periodically take a snapshot of this buffer and output it to the console as a complete frame. By swapping or copying from the back buffer to the front for display, we ensure the screen only updates when a full frame is ready, not in mid-update​. This technique “uses a memory buffer to address the flicker problems” associated with incremental drawing. In simpler terms, all the drawing (character updates) happens hidden, then one big blit of the fully-drawn frame is done to the console, eliminating flicker. Our implementation achieves double buffering by using the mutex to coordinate when the main printing happens. For example, the main loop might lock the bufferMutex, copy the entire screenBuffer into a local temporary (or swap pointers between back and front buffers), then unlock and print the snapshot. The worker threads, on the other hand, lock the mutex while making changes, then release. This way, the main thread never prints half-finished data. The end result is a smooth animation of green characters cascading down, with no perceptible tearing. It’s worth noting that updating the console in real-time is relatively slow (the console is not a high-performance graphics engine). We tuned the refresh rate (using sleeps) to ensure the effect looked smooth but also didn’t hog 100% CPU. std::this_thread::sleep_for was used extensively to manage timing – both for individual column speed and for the frame rate of printing to screen. By experimenting with different delays (e.g., column updates every 50ms–200ms randomized, and screen refresh ~30 times per second), we found a balance that produces a pleasing effect. Another aspect of the algorithm is initialization and termination. At startup, after launching threads, the main thread could wait for a key press or run for a certain duration. When it’s time to exit, we set simulationRunning = false (a shared atomic or volatile flag), and join all threads. This causes each thread’s loop to break neatly and ensures all threads finish execution before the program ends. We also handle any cleanup, though thanks to RAII (vectors free their memory automatically, etc.) there isn’t much manual cleanup needed beyond joining threads. In summary, the algorithm combines concurrency (multiple threads updating different parts of the screen), randomness (random chars and speeds for realism), and graphics techniques (double buffering to avoid flicker). By using modern C++ constructs (std::thread, mutexes, <random> engines), the code remains succinct and expressive. The core logic is only a few dozen lines, but orchestrating it required careful attention to threading and synchronization, which we will discuss next.

## Problem-Solving and Challenges
Building this project was not without its challenges. Here we reflect on the main problems encountered and how we solved them, using modern C++ tools and sound engineering principles:
Screen Flicker and Tearing: In early versions, printing characters directly to the console as they changed led to a lot of flicker. Parts of the screen would update at different times, producing an unsightly tearing effect. We resolved this by implementing double buffering. As described above, double buffering means drawing the next frame off-screen and then outputting it in one operation. By doing so, “the image flickering associated with complex painting operations is eliminated”​. We created a back buffer for the screen state that threads write to, and only copied from this back buffer to the console output at a controlled interval. This way, the console is updated frame-by-frame, not character-by-character, preventing flicker.
Concurrency and Data Races: Managing multiple threads writing to a shared buffer introduced the risk of data races (two threads modifying the same data simultaneously) and inconsistencies. The solution was to use a mutex to protect the shared data. A mutex (mutual exclusion) is essentially a lock that threads must acquire before entering a critical section of code. According to C++ reference documentation, “a mutex is a lockable object designed to signal when critical sections of code need exclusive access, preventing other threads with the same protection from executing concurrently”​. In our code, anytime a thread needs to modify the screenBuffer, it first locks a std::mutex. This ensures one thread completes its update before another starts, so updates don’t interfere with each other. We used std::lock_guard to manage the mutex automatically (locking on creation and unlocking when it goes out of scope), which is an RAII approach to thread synchronization. The result is that even with many threads, the screenBuffer remains consistent and correct. No more garbled characters or weird overlaps occurred after this fix.
Thread Coordination and Lifecycle: Another challenge was coordinating the start and stop of threads. We had to ensure all threads begin updating around the same time and that we can stop them cleanly. We addressed this by using flags and proper thread joins. For instance, we have a boolean simulationRunning shared by all threads. Each thread checks this flag in its loop; when we want to stop (for example, the user presses a key), the main thread sets simulationRunning = false. Each worker thread then breaks out of its loop and terminates. The main thread calls join() on each thread to wait for their completion. By joining threads, we make sure the program doesn’t exit prematurely with threads still running. This careful shutdown procedure prevented issues such as crashes on exit or characters still printing after the program was supposed to have stopped.
Randomness Quality: Using good random generation was important for realism. Initially, one might try rand() from <cstdlib>, but this produces poor quality random numbers and can repeat patterns, diminishing the effect. We switched to C++11’s <random> facilities. Using std::mt19937 (Mersenne Twister engine) gave us a high-quality pseudorandom sequence for characters. We seed the engine with std::random_device (for true entropy) or a time-based seed so each run is different. The improvement was noticeable in that the code rain no longer showed obvious repeating cycles. It’s worth noting the advice: “C++ random-number library is so much better than C’s. Don’t use C’s rand() anymore.”​ – which we heeded. The uniform distribution ensured each character is equally likely, making the rain appear truly random.
Exception Safety: While developing, we considered what would happen if something went wrong (for example, memory allocation failure, or an exception thrown in a thread). Modern C++ encourages using exceptions to handle error conditions, rather than error codes, because exceptions separate error-handling logic from regular code flow​. In our project, there were few error conditions that would throw exceptions (most logic is straightforward), but we still ensured our code was exception-safe. Thanks to RAII, if an exception did occur, resources would free automatically: threads in std::vector would be joined in the destructor, locks would be released by std::lock_guard, and vectors would free their memory. We also avoided throwing exceptions in destructors or during unwinding, following best practices. By writing robust code that respects these principles, we minimize the chance of crashes or resource leaks in unexpected situations.
Performance Tuning: Printing to a console rapidly can be slow, and using many threads can also incur overhead. We had to tune the number of threads and the delays. Using one thread per column was simple but could overwhelm the system if the width was large. We found that grouping some columns per thread or limiting the total threads might be beneficial in some cases. However, C++ threads are quite lightweight, and on a multi-core CPU, the load was spread out. We also made sure not to update more frequently than necessary. By experimenting (e.g., if we reduce the sleep too much, CPU usage spikes with little visual gain), we identified reasonable defaults for smooth animation without excessive CPU use.
Each of these challenges reinforced important lessons. The flicker issue taught us about double buffering, a technique widely used in game development and graphics to produce smooth visuals​. The data race issue gave hands-on experience with mutexes and thread synchronization – a critical aspect of concurrent programming. The need for clean thread management underscored the value of RAII and the rule of five, ensuring that our class could be safely created and destroyed without surprises. And improving randomness and error handling aligned with using the best of the C++ standard library and best practices rather than older C-style approaches.

## Reflection and Insights into Modern C++
Developing the Matrix digital rain project was not only fun but also an illuminating exercise in applying modern C++ techniques. Here, we reflect on some key insights and takeaways, connecting them to broader C++ concepts and course principles: 1. The Power of RAII and Smart Resource Management: One of the strongest impressions from this project is how much easier resource management becomes when following RAII. By tying resources (like dynamic memory, file handles, or threads) to object lifetimes, we avoid many pitfalls. We saw this with std::lock_guard for mutexes – we never have to remember to unlock a mutex in every code path, it unlocks itself when the guard goes out of scope. Similarly, using std::vector instead of manual new/delete means memory is automatically freed when the vector is destroyed. RAII “binds the lifecycle of a resource to the lifetime of an object”​, and the C++ standard library containers and classes (e.g., std::string, std::vector) all follow this idiom​. This project drove home why RAII is emphasized in C++: it leads to safer, cleaner code. The Core Guidelines put it succinctly: “Use RAII to prevent leaks.”​
We adhered to that, and indeed our program has no explicit new or delete calls – memory and locks are managed by objects that clean up automatically. 2. Encapsulation and Object-Oriented Design: By modeling the problem with classes (DigitalRain, perhaps a Column struct, etc.), we achieved a natural separation of concerns. Encapsulation ensured that the rest of the program didn’t need to know about the gritty details of how the screen buffer is managed or how threads synchronize – it just calls an interface to start and stop the rain. This aligns with the idea that a class should manage a single abstraction (Single Responsibility Principle) and keep its internal data private​. The benefits became clear as the project grew: if we needed to change how the buffer works (say, use a different data structure), we could do so inside the class without affecting other code. The lectures highlighted principles like “Don’t Repeat Yourself” and “Keep It Simple”, which we followed by centralizing logic (no duplicated code for updating columns – we wrote it once and reused it for every thread) and keeping functions focused and short. Overall, embracing basic OO principles made the code more understandable and easier to debug. 3. Modern C++ Libraries and Features: This project would have been much harder or more error-prone if attempted with pre-C++11 tools. The introduction of threads into the C++ standard (C++11) saved us from resorting to platform-specific APIs (like pthreads on Unix or CreateThread on Windows). We simply included <thread> and got portable concurrency. Similarly, <random> gave us robust RNG facilities. We didn’t have to write our own random generator or use the weak rand(). The <mutex> and <chrono> libraries allowed us to manage synchronization and timing in a straightforward manner. Using these standard library features is in line with the advice: “Use the standard library before reinventing features.”​
 Not only did this save development time, it also meant our code is likely more reliable, since these components are well-tested. We also used modern language features: for instance, we might use range-based for loops for clarity, auto for type deduction to reduce verbosity, and lambda functions to launch threads with inline tasks. All these contribute to what we often call “modern C++ style” – code that is more expressive and safer than the old hand-coded C-style approaches. 4. The Rule of Five and Designing for Correctness: Although a small project, we still paid attention to writing strong class definitions. We considered the Rule of Three/Five, which was a topic in our course for designing copyable classes. In our scenario, we leveraged the rule of five by deleting the copy operations, because sharing threads or buffers between copied objects could lead to chaos. This was a conscious design decision: either implement deep copy or disable copying. We chose to disable it, which is a valid approach (especially following the “Rule of Zero/Three” philosophy: if a class doesn’t need to be copied, just let the compiler handle it or delete as needed). Writing out the special member functions explicitly made us reason about ownership and object lifetime carefully​. This is a very C++-specific insight – the language gives you control to prevent misuse (like accidentally copying a heavy object). By understanding these concepts, we made our code more robust. It’s better to get a compile-time error for a deleted copy constructor than to have a subtle runtime bug from an unintended copy. 5. Threading and Mutexes – Learning to Handle Concurrency: This project was likely one of our first forays into multi-threaded programming in C++. It vividly demonstrated why things like mutexes are needed. We experienced the effects of race conditions firsthand (strange outputs when forgetting to lock, etc.) and fixed them with proper locking. We also saw how easy it is to create threads, but also the responsibility that comes with it – ensuring they are coordinated and joined. The concept of a deadlock was kept in mind (fortunately, our locking strategy was simple: a single mutex guarding a simple resource, so we didn’t encounter deadlocks). Working with threads also taught us about the cost of context switching and the importance of not having threads spin at full speed doing nothing (hence using sleeps). In essence, we got a practical taste of concurrent programming, underlining the importance of cautious design in such scenarios. 6. Exception Handling Philosophy: While our use of exceptions was limited, designing with exceptions in mind improved the overall quality. We followed the guideline that one should prefer exceptions for error handling in C++ for truly exceptional conditions (rather than error codes littered through logic)​. By ensuring our destructors can handle an exception (or at least not throw their own) and that RAII wraps up resources during unwinding, we made the code exception-safe almost by construction. This forward-thinking design means the program is resilient: if something did go wrong, it would clean up and could report an error, rather than crash or leak. 7. Tying it All Together – Software Engineering in Practice: Finally, reflecting on the project as a whole, it served as a microcosm of software engineering principles. We started from a problem (make the Matrix rain), we designed a solution (using classes, thinking about data structures and threads), we implemented it with attention to best practices (standard library, RAII, clean code), we tested and iterated (fixing flicker, ensuring thread safety), and we ended up with a publishable piece of software. This mirrors the development cycle emphasized in the course. We also integrated multiple concepts from the curriculum: from basic OOP to advanced C++11 features, from algorithmic thinking (how to shift columns efficiently) to debugging and optimization. The project might seem niche (console animation), but the skills and insights gained are broadly applicable to any software project in C++. In conclusion, creating the Matrix digital rain in C++ was a rewarding exercise that went beyond making green characters fall on the screen. It reinforced why modern C++ is such a powerful language – features like threads, random engines, and smart pointers/RAII utilities let us focus on what we want to do instead of the low-level how. It also underscored the importance of good design and adherence to principles. The final program not only looks visually interesting, but under the hood it is structured, efficient, and robust, which is something to be proud of as a C++ developer. The journey through design, problem-solving, and reflection here hopefully provides a clear narrative of how the project came together and what was learned along the way. Writing about it in a formal, reflective way – as we’ve done – helps solidify those learnings and perhaps will guide others on similar paths. The Matrix might be fiction, but the coding skills we sharpened here are very real and will surely benefit our future projects.
<img src="https://raw.githubusercontent.com/G00405094/DigitalRain/main/docs/assets/images/RainImage.jpg" width="400" height="300">
